<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 能工巧匠集 | OneV's Den]]></title>
  <link href="http://onevcat.com/category/neng-gong-qiao-jiang-ji/atom.xml" rel="self"/>
  <link href="http://onevcat.com/"/>
  <updated>2013-06-15T15:31:44+09:00</updated>
  <id>http://onevcat.com/</id>
  <author>
    <name><![CDATA[onevcat]]></name>
    <email><![CDATA[onev@onevcat.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[uikit-dynamics-started]]></title>
    <link href="http://onevcat.com/2013/06/uikit-dynamics-started/"/>
    <updated>2013-06-15T15:11:00+09:00</updated>
    <id>http://onevcat.com/2013/06/uikit-dynamics-started</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WWDC2013笔记 Xcode5和ObjC新特性]]></title>
    <link href="http://onevcat.com/2013/06/new-in-xcode5-and-objc/"/>
    <updated>2013-06-13T10:05:00+09:00</updated>
    <id>http://onevcat.com/2013/06/new-in-xcode5-and-objc</id>
    <content type="html"><![CDATA[<p><img src="http://img.onevcat.com/2013/xcode5-title.png" alt="Welcome to Xcode 5" /></p>

<p>这是我的WWDC2013系列笔记中的一篇，完整的笔记列表请参看<a href="http://onevcat.com/2013/06/developer-should-know-about-ios7/">这篇总览</a>。本文欢迎转载，但烦请保留原文链接出处（http://onevcat.com/2013/06/new-in-xcode5-and-objc/），不胜感激。</p>

<p>本文涉及到的WWDC2013 Session有</p>

<ul>
<li>Session 400 What's New in Xcode 5</li>
<li>Session 401 Xcode Core Concepts</li>
<li>Session 407 Debugging with Xcode</li>
<li>Session 404 Advances in Objective-C</li>
</ul>


<p>等Tools模块下的内容</p>

<p>随着iOS7 SDK的beta放出，以及Xcode 5 DP版本的到来，很多为iOS7开发应用的方式已经逐渐浮现。可以豪不夸张地讲，由于iOS7的UI发生了重大变革，此次的升级不同于以往，我们将会迎来iOS开发诞生以来最剧烈的变动，如何拥抱变化，快速适应新的世界和平台，值得每个Cocoa和CocoaTouch开发者研究。工欲善其事，必先利其器。想做iOS7的开发，就必须切换到Xcode5和新的ObjC体系（包括新引入的语法和编译器），在这里我简要地对新添加或重大变化的功能做一个小结。</p>

<h2>说说新的Xcode</h2>

<p>Xcode4刚出的时候存在茫茫多似乎无穷无尽的bug（如果是一路走来的同仁可能对此还记忆犹新），好消息是这次Xcode5 DP版本似乎相当稳定，如果你遇到了开启新Xcode就报错强退的话，多半原因是因为你在使用为Xcode4制作的插件，不同版本的Xcode是共用同一个文件夹下的插件的，请将<code>~/Library/Application Support/Developer/Shared/Xcode/Plug-ins</code>目录下的内容清理一下，应该就能顺利进入Xcode5了。</p>

<!-- more -->


<p>Xcode 5现在使用了ARC，取代了原来的垃圾回收（Garbage collection）机制，因此不论从启动速度和使用速度上来说都比之前快了不少。现在大部分的AppStore提交应用也都使用了ARC，新SDK中加入的系统框架也全都是ARC的了。另外，在Xcode5中新建工程也不再提供是否使用ARC的选项（虽然也还是可以在Build Setting中关掉）。如果你还在使用手动内存管理的话，现在是时候抛弃release什么的了，如果你还在迷茫应该应该怎么使用ARC，可以参看一下去年这个时候我发的一篇<a href="http://onevcat.com/2012/06/arc-hand-by-hand/">ARC的教程文章</a>。</p>

<h3>界面变化</h3>

<p><img src="http://img.onevcat.com/2013/xcode5-header.png" alt="Xcode5减小了顶栏宽度" /></p>

<p>首先值得称赞的是顶部工具栏的变化，新版中贯彻了精简的原则，将顶栏砍掉了30%左右的宽度，对于小屏幕来说绝对是福音。另外，在外观上界面也向平面和简洁的方向迈进了一大步，可算是对iOS7的遥相呼应吧。</p>

<h3>更易用的版本管理</h3>

<p><img src="http://img.onevcat.com/2013/xcode5-sourcecontrol.png" alt="image" /></p>

<p>虽然在Xcode 4里就集成了版本管理的内容，但是一直被藏的很深，很多时候开发者不得不打开Organizer才能找到对应操作的地方。与之相比，Xcode5为版本管理留出了专门的一个<code>Source Control</code>菜单，从此以后妈妈再也不用担心我找不到git放哪儿了。集成的版本管理可以方便地完成大部分初级功能，包括Check Out，Pull，Commit，Push，Merge等，特别是在建立仓库和检出仓库时十分方便。但是在遇到稍微复杂的git操作时还是感到力不从心（比如rebase或摘樱桃的时候），这点上毕竟Xcode并不是一个版本管理app，而最基本的几个操作在日常工作中也算能快速地应付绝大部分情况（在不将工程文件添加到版本管理的情况下）。</p>

<p>值得称赞的是在编辑代码的时候，可以直接对某一行进行blame了，在该行点击右键选Show Blame for Line，就能看到最后改动的人的信息。另外，Version Editor（View->Version Editor）也除了之前就有的版本对比之外，还新加了Blame和Log两种视图。在对代码历史追溯这块，Xcode5现在已经做的足够好了.</p>

<p>结论是，虽然有所进步，但是Xcode的内置版本管理仍然不堪大任，命令行或者一个专业的git管理工具还是必要的。</p>

<h3>方便的工程配置</h3>

<p>与版本管理的强化相比较，工程配置方面也进行了很多加强，简化了之前开发者的需要做的一些配置工作。首先是在Build Setting的General里，加入了Team的设置，只要填写对应的Apple ID和应用Bundle ID，Xcode就将自动去寻找对应的Provisioning Profile，并使用合适的Provisioning来进行应用打包。因为有了自动配置和将集成的版本管理放到了菜单栏中，Organizer的地位被大大削弱了。至少我现在在Organizer中没有找到本机的证书管理和Provisioning Profile管理的地方，唯一开Organizer的理由大概就是应用打包发布时了。想想从远古时代的Application Loader一步一步走到现在，Xcode可以说在简化流程，帮助开发者快速发布应用方面做了很大努力。</p>

<p>另一个重要改进是在Build选项中加入了<code>Capabilities</code>标签，如下图</p>

<p><img src="http://img.onevcat.com/2013/xcode5-capabilities.png" alt="Xcode5的Capabilities" /></p>

<p>想想看以前为app配置iCloud要花的步骤吧：到Apple Developer里找到应用的ID，打开对应的app的iCloud功能，生成对应的Provisioning文件，回到Xcode创建一个Entitlements文件，定义Key-Value Store，Ubiquity Containers和Keychain Groups，然后你才能开始为应用创建UIDocument并且继续开发。哦天啊…作为学习来说做一次还能接受，但是如果每次开发应用都要来一遍这个过程，只能用枯燥乏味四个字来形容了。于是，正如你所看到的，现在你需要做的是，点一下iCloud的开关，然后…开始编程吧～轻松惬意。同样的方法也适用于Apple提供的其他服务，包括打开和配置GameCenter，Passbook，IAP，Maps，Keychain，后台模式和Data Protection，当然还有iOS7新加入的Inter-app Audio。这些小开关做的事情都很简单，但确实十分贴心。</p>

<h3>资源管理，Asset Catalog和Image Slicing</h3>

<p>资源目录(Asset Catalog)和图像切片(Image Slicing)是Xcode5新加入的功能。资源目录可以方便开发者管理工程中使用的图片素材，利用开发中的命名规则（比如高清图的@2x，图标的Icon，Splash的Default等），来筛选和分类图片。建立一个资源目录十分简单，如果是老版本导入的工程，在工程设置中图标或者splash图的设置中点击<code>Use Asset Catalog</code>，Xcode将建立新的资源目录；如果是直接使用Xcode 5建立的工程的话，那么资源目录应该已经默认躺在工程中了。</p>

<p><img src="http://img.onevcat.com/2013/xcode5-asset-catalog.png" alt="添加一个Asset Catalog" /></p>

<p>添加资源目录后，在工程中会新加一个.xcassets后缀的目录用以整理和存放图片，该文件夹中存放了图片和对应的json文件来保存图片信息。为了能够使用资源目录的特性，以及更好的前向兼容性，建议将所有的图片资源都加入资源目录中：在工程中选择.xcassets文件，然后在资源目录中点击加号即可添加图片。另外，直接从工程外的Finder中将图片拖动到Xcode的资源目录界面中，也将把拖进来的图片拷贝并添加到资源目录中。对的，不再会有讨厌的弹窗出来，问你要拷贝还是要引用了。</p>

<p><img src="http://img.onevcat.com/2013/xcode5-add-ac.png" alt="在Asset Catalog中添加图片" /></p>

<p>Asset Catalog的意义在于为工程中的图片提供了一个存储信息的地方，不仅可以描述资源对应的设备，资源的版本和更新信息等，更重要的在于可以为Image Slicing服务。所谓Image Slicing，相当于一个可视化的<code>resizableImageWithCapInsets:resizingMode:</code>，可以用于指定在图片缩放时用来填充的像素。在资源目录中选择要slicing的图片，点击图片界面右下方的Show Slicing按钮，在想要设定切片的图片上点击<code>Start Slicing</code>，将出现左中右（或者上中下）三条可以拖动的指示线，通过拖动它们来设定实际的缩放范围。</p>

<p><img src="http://img.onevcat.com/2013/xcode5-slicing.png" alt="设定Image Slicing" /></p>

<p>在左侧线（或者上方线）和中间线之间的像素将在缩放时被填充，在中间线和右侧线（或者下方线）之间的像素将被隐藏。比如上面的例子，实际运行中如果对这张图片进行拉伸的话，会是下面的样子：</p>

<p><img src="http://img.onevcat.com/2013/xcode5-slicing-image.png" alt="拉升Image Slicing后的图片" /></p>

<p>Image Slicing可以帮助开发者用可视化的方式完成resizable image，之后通过拖拖线就可以完成sliced image，而不必再写代码，也不用再一次次尝试输入的insets合不合适了。slicing可缩放的图片大量用于UI中可以节省打包的占用空间，而在Xcode 5中引入和加强图片资源管理的目的，很大一部分是为了配合SpriteKit将游戏引擎加入到SDK中，并将Xcode逐渐打造为一个全面的IDE工具。</p>

<h3>新的调试和辅助功能</h3>

<p>这应该是Xcode5最值得称赞的改进了，在调试中现在在编辑框内鼠标悬浮在变量名上，Xcode将会根据类型进行猜测，并输出最合适的结果以帮助观察。就像这样：</p>

<p><img src="http://img.onevcat.com/2013/xcode5-debug-mouseover.png" alt="鼠标悬浮就可以出现变量结果" /></p>

<p>以前版本的Xcode虽然也有鼠标悬浮提示，但是想从中找到想要的value确实还是比较麻烦的事情，很多时候我们不得不参考下面Variables View的值或者直接p或者po它们，现在如果只是需要知道变量情况的话，在断到代码后一路用鼠标跟着代码走一遍，就差不多了然于胸了。如果你认为鼠标悬停只能打打字符串或者数字的话你就错了，数组，字典什么的也不在话下，更过分的是设计图像的也能很好地显示，只需要点击预览按钮，就像这样：</p>

<p><img src="http://img.onevcat.com/2013/xcode5-debug-image.png" alt="直接悬停显示图片" /></p>

<p>Xcode5集成了一个Debug面板，用来实现一个简单的Profiler，可以在调试时直接看到应用的CPU消耗，内存使用等情况（其他的还有iCloud情况，功耗和图形性能等）。在Debug运行时Cmd+6即可切换到该Debug界面。监测的内容简单明了，CPU使用用来检查是否有高占用或者尖峰（特别是主线程中），内存检测用来检查内存使用和释放的情况是否符合预期。</p>

<p><img src="http://img.onevcat.com/2013/xcode5-debug-profiler.png" alt="Debug的Profiler面板" /></p>

<p>如果养成开发过程的调试中就一直打开这个Profiler面板的话（至少我从之后会坚持这个做法了），相信是有助于在开发过程中就迅速的监测到潜在的问题，并迅速解决的。当然，对于明显的问题可以在Debug面板中发现后立即寻找对应代码解决，但是如果比较复杂的问题，想要知道详细情况的话，还是要使用Instruments，在Debug面板中提供了一个“Profile In Instruments”按钮，可以快速跳转到Instruments。</p>

<p>最后，Xcode在注释式文档方面也有进步，现在如下格式的注释将在Xcode中直接被检测到并集成进代码提示中了：</p>

<p><code>objc
/**
 * Setup a recorder for a specified file path. After setting it, you can use the other control method to control the shared recorder.
 *
 * @param talkingPath An NSString indicates in which path the recording should be created
 * @returns YES if recorder setup correctly, NO if there is an error
 */
- (BOOL)recordWithFilePath:(NSString *)talkingPath;
</code></p>

<p>得到的结果是这样的</p>

<p><img src="http://img.onevcat.com/2013/xcode5-comment-doc.png" alt="Xcode对代码注释的解析" /></p>

<p>以及Quick Help中会有详细信息</p>

<p><img src="http://img.onevcat.com/2013/xcode5-quickhelp.png" alt="在Quick Help中显示详细文档" /></p>

<p>Xcode现在可以识别Javadoc格式（类似于上面例子）的注释文档，可用的标识符除了上面的<code>@param</code>和<code>@return</code>外，还有例如<code>@see</code>，<code>@discussion</code>等，关于Javadoc的更多格式规则，可以参考<a href="http://en.wikipedia.org/wiki/Javadoc">Wiki</a>。</p>

<h2>关于Objective-C，Modules和Autolinking</h2>

<p>OC自从Apple接手后，一直在不断改进。随着移动开发带来的OC开发者井喷式增加，客观上也要求Apple需要提供各种良好特性来支持这样一个庞大的开发者社区。iOS4时代的GCD，iOS5时代的ARC，iOS6时代的各种简化，每年我们都能看到OC在成为一种先进语言上的努力。基于SmallTalk和runtime，本身是C的超集，如此“根正苗红”的一门语言，在今年也迎来的新的变化。</p>

<p>今年OC的最大变化就是加入了Modules和Autolinking。</p>

<h3>什么是Modules呢</h3>

<p>在了解Modules之前我们需要先了解一下OC的import机制。<code>#import &lt;FrameworkFoo/HeaderBar.h&gt;</code>，我相信每个开发者都写过这样的代码，用来引用其他的头文件。熟悉C或者C++的童鞋可能会知道，在C和C++里是没有#import的，只有#include（虽然GCC现在为C和C++做了特殊处理使得imoprt可以被编译），用来包含头文件。#include做的事情其实就是简单的复制粘贴，将目标.h文件中的内容一字不落地拷贝到当前文件中，并替换掉这句include，而#import实质上做的事情和#include是一样的，只不过OC为了避免重复引用可能带来的编译错误（这种情况在引用关系复杂的时候很可能发生，比如B和C都引用了A，D又同时引用了B和C，这样A中定义的东西就在D中被定义了两次，重复了），而加入了#import，从而保证每个头文件只会被引用一次。</p>

<blockquote><p>如果想深究，import的实现是通过#ifndef一个标志进行判断，然后在引入后#define这个标志，来避免重复引用的</p></blockquote>

<p>实质上import也还是拷贝粘贴，这样就带来一个问题：当引用关系很复杂，或者一个头文件被非常多的实现文件引用时，编译时引用所占的代码量就会大幅上升（因为被引用的头文件在各个地方都被copy了一遍）。为了解决这个问题，C系语言引入了预编译头文件（PreCompiled Header），将公用的头文件放入预编译头文件中预先进行编译，然后在真正编译工程时再将预先编译好的产物加入到所有待编译的Source中去，来加快编译速度。比如iOS开发中Supporting Files组内的.pch文件就是一个预编译头文件，默认情况下，它引用了UIKit和Foundation两个头文件--这是在iOS开发中基本每个实现文件都会用到的东西。</p>

<p>于是理论上说，想要提高编译速度，可以把所有头文件引用都放到pch中。但是这样面临的问题是在工程中随处可用本来不应该能访问的东西，而编译器也无法准确给出错误或者警告，无形中增加了出错的可能性。</p>

<p>于是Modules诞生了。Modules相当于将框架进行了封装，然后加入在实际编译之时加入了一个用来存放已编译添加过的Modules列表。如果在编译的文件中引用到某个Modules的话，将首先在这个列表内查找，找到的话说明已经被加载过则直接使用已有的，如果没有找到，则把引用的头文件编译后加入到这个表中。这样被引用到的Modules只会被编译一次，但是在开发时又不会被意外使用到，从而同时解决了编译时间和引用泛滥两方面的问题。</p>

<p>稍微追根问底，Modules是什么？其实无非是对框架进行了如下封装，拿UIKit为例：</p>

<p>```objc
framework module UIKit {</p>

<pre><code>umbrella header "UIKit.h"
module * {export *}
link framework "UIKit"
</code></pre>

<p>}
```</p>

<p>这个Module定义了首要头文件（UIKit.h），需要导出的子modules（所有），以及需要link的框架名称（UIKit）。需要指出的是，现在Module还不支持第三方的框架，所以只有SDK内置的框架能够从这个特性中受益。另外，在C++的源代码中，Modules也是被禁用的。</p>

<h3>好了，说了那么多，这玩意儿怎么用呢</h3>

<p>关于普通开发者使用的这个新特性的方法，Apple在LLVM5.0（也就是Xcode5带的最新的编译器前端中）引入了一个新的编译符号<code>@import</code>，使用@符号将告诉编译器去使用Modules的引用形式，从而获取好处，比如想引用MessageUI，可以写成</p>

<p><code>objc
@import MessageUI;
</code></p>

<p>在使用上，这将等价于以前的<code>#import &lt;MessageUI/MessageUI.h&gt;</code>，但是将使用Modules的特性。如果只想使用某个特性的.h文件，比如<code>#import &lt;MessageUI/MFMailComposeViewController.h&gt;</code>，对应写作</p>

<p><code>objc
@import MessageUI.MFMailComposeViewController;
</code>
当然，如果对于以前的工程，想要使用新的Modules特性，如果要把所有头文件都这样一个一个改成<code>@import</code>的话，会是很大的一个工作量。Apple自然也考虑到了这一点，于是对于原来的代码，只要使用的是iOS7或者MacOS10.9的SDK，在Build Settings中将Enable Modules(C and Objective-C)打开，然后保持原来的<code>#import</code>写法就行了。是的，不需要任何代码上的改变，编译器会在编译的时候自动地把可能的地方换成Modules的写法去编译的。</p>

<p>Autolinking是Modules的附赠小惊喜，因为在module定义的时候指定来link framework，所以在编译module时LLVM会将所涉及到的框架自动帮你写到link里去，不再需要到编译设置里去添加了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开发者所需要知道的iOS7 SDK新特性]]></title>
    <link href="http://onevcat.com/2013/06/developer-should-know-about-ios7/"/>
    <updated>2013-06-11T07:43:00+09:00</updated>
    <id>http://onevcat.com/2013/06/developer-should-know-about-ios7</id>
    <content type="html"><![CDATA[<p><img src="http://img.onevcat.com/2013/ios-7-logo.png" alt="iOS 7" /></p>

<p>春风又绿加州岸，物是人非又一年。WWDC 2013 keynote落下帷幕，新的iOS开发旅程也由此开启。在iOS7界面重大变革的背后，开发者们需要知道的又有哪些呢。同去年一样，我会先简单纵览地介绍iOS7中我个人认为开发者需要着重关注和学习的内容，之后再陆续对自己感兴趣章节进行探索。计划继承类似<a href="http://onevcat.com/2012/06/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%80%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84ios6-sdk%E6%96%B0%E7%89%B9%E6%80%A7/">WWDC2012的笔记</a>的形式，希望对国内开发者有所帮助。</p>

<p>相关笔记整理如下：</p>

<ul>
<li>总览 <a href="http://onevcat.com/2013/06/developer-should-know-about-ios7/">开发者所需要知道的iOS7 SDK新特性</a></li>
<li>工具 <a href="http://onevcat.com/2013/06/new-in-xcode5-and-objc/">WWDC2013笔记 Xcode5和ObjC新特性</a></li>
</ul>


<hr />

<h3>UI相关</h3>

<h4>全新UI设计</h4>

<p>iOS7最大的变化莫过于UI设计，也许你会说UI设计“这是设计师大大们应该关注的事情，不关开发者的事，我们只需要替换图片就行了”。那你就错了。UI的变化必然带来使用习惯和方式的转变，如何运用iOS7的UI，如何是自己的应用更切合新的系统，都是需要考虑的事情。另外值得注意的是，使用iOS7 SDK（现在只有Xcode5预览版提供）打包的应用在iOS7上运行时将会自动使用iOS7的新界面，所以原有应用可能需要对新界面进行重大调整。具体的iOS7中所使用的UI元素的人际交互界面文档，可以从<a href="https://developer.apple.com/library/prerelease/ios/design/index.html#//apple_ref/doc/uid/TP40013289">这里</a>找到（应该是需要开发者账号才能看）。</p>

<p>简单总结来说，以现在上手体验看来新的UI变化改进有如下几点：</p>

<ul>
<li>状态栏，导航栏和应用实际展示内容不再界限：系统自带的应用都不再区分状态栏和navigation bar，而是用统一的颜色力求简洁。这也算是一种趋势。</li>
<li>BarItem的按钮全部文字化：这点做的相当坚决，所有的导航和工具条按钮都取消了拟物化，原来的文字（比如“Edit”，“Done”之类）改为了简单的文字，原来的图标（比如新建或者删除）也做了简化。</li>
<li>程序打开加入了动画：从主界面到图标所在位置的一个放大，同时显示应用的载入界面。</li>
</ul>


<p>自己实验了几个现有的AppStore应用在iOS7上的运行情况：</p>

<ul>
<li><a href="https://itunes.apple.com/app/id533469911?mt=8">Pomodoro Do</a>： 这是我自己开发的应用，运行正常，但是因为不是iOS7 SDK打包，所以在UI上使用了之前系统的，问题是导航栏Tint颜色丢失，导致很难看，需要尽快更新。</li>
<li>Facebook：因为使用了图片自定义导航栏，而没有直接使用系统提供的材质，所以没什么问题。</li>
<li>面包旅行：直接Crash，无法打开，原因未知。</li>
</ul>


<!-- more -->


<p>这次UI大改可以说是一次对敏捷开发的检验，原来的应用（特别是拟物化用得比较重的应用）虽然也能运行，但是很多UI自定义的地方需要更改不说，还容易让用户产生一种“来到了另一个世界”的感觉，同时可以看到也有部分应用无法运行。而对于苹果的封闭系统和只升不降的特性，开发者以及其应用必须要尽快适应这个新系统，这对于迭代快速，还在继续维护的应用来说会是一个机会。相信谁先能适应新的UI，谁就将在iOS7上占到先机。</p>

<h4>UIKit的力学模型（UIKit Dynamics）</h4>

<p>新增了<code>UIDynamicItem</code>委托，用来为UIView制定力学模型行为，当然其他任何对象都能通过实现这组接口来定义动力学行为，只不过在UIKit中可能应用最多。所谓动力学行为，是指将现实世界的我们常见的力学行为或者特性引入到UI中，比如重力等。通过实现UIDynamicItem，UIKit现在支持如下行为：</p>

<ul>
<li>UIAttachmentBehavior 连接两个实现了UIDynamicItem的物体（以下简称动力物体），一个物体移动时，另一个跟随移动</li>
<li>UICollisionBehavior 指定边界，使两个动力物体可以进行碰撞</li>
<li>UIGravityBehavior 顾名思义，为动力物体增加重力模拟</li>
<li>UIPushBehavior 为动力物体施加持续的力</li>
<li>UISnapBehavior 为动力物体指定一个附着点，想象一下类似挂一幅画在图钉上的感觉</li>
</ul>


<p>如果有开发游戏的童鞋可能会觉得这些很多都是做游戏时候的需求，一种box2d之类的2D物理引擎的既视感跃然而出。没错的亲，动态UI，加上之后要介绍的Sprite Kit，极大的扩展了使用UIKit进行游戏开发的可能性。另外要注意UIDynamicItem不仅适用于UIKit，任何对象都可以实现接口来获得动态物体的一些特性，所以说用来做一些3D的或者其他奇怪有趣的事情也不是没有可能。如果觉得Cocos2D+box2d这样的组合使用起来不方便的话，现在动态UIKit+SpriteKit给出了新的选择。</p>

<h3>游戏方面</h3>

<p>iOS7 SDK极大加强了直接使用iOS SDK制作和分发游戏的体验，最主要的是引入了专门的游戏制作框架。</p>

<h4>Sprite Kit Framework</h4>

<p>这是个人认为iOS7 SDK最大的亮点，也是最重要的部分，iOS SDK终于有自己的精灵系统了。Sprite Kit Framework使用硬件加速的动画系统来表现2D和2.5D的游戏，它提供了制作游戏所需要的大部分的工具，包括图像渲染，动画系统，声音播放以及图像模拟的物理引擎。可以说这个框架是iOS SDK自带了一个较完备的2D游戏引擎，力图让开发者专注于更高层的实现和内容。和大多数游戏引擎一样，Sprite Kit内的内容都按照场景（Scene）来分开组织，一个场景可以包括贴图对象，视频，形状，粒子效果甚至是CoreImage滤镜等等。相对于现有的2D引擎来说，由于Sprite Kit是在系统层级进行的优化，渲染时间等都由框架决定，因此应该会有比较高的效率。</p>

<p>另外，Xcode还提供了创建粒子系统和贴图Atlas的工具。使用Xcode来管理粒子效果和贴图atlas，可以迅速在Sprite Kit中反应出来。</p>

<h4>Game Controller Framework</h4>

<p>为Made-for-iPhone/iPod/iPad (MFi) game controller设计的硬件的对应的框架，可以让用户用来连接和控制专门的游戏硬件。参考WWDC 2013开场视频中开始的赛车演示。现在想到的是，也许这货不仅可以用于游戏…或者苹果之后会扩展其应用，因为使用普及率很高的iPhone作为物联网的入口，似乎会是很有前途的事情。</p>

<h4>GameCenter改进</h4>

<p>GameCenter一直是苹果的败笔...虽然每年都在改进，但是一直没看到大的起色。今年也不例外，都是些小改动，不提也罢。</p>

<h3>多任务强化</h3>

<ul>
<li>经常需要下载新内容的应用现在可以通过设置<code>UIBackgroundModes</code>为<code>fetch</code>来实现后台下载内容了，需要在AppDelegate里实现<code>setMinimumBackgroundFetchInterval:</code>以及<code>application:performFetchWithCompletionHandler:</code>来处理完成的下载，这个为后台运行代码提供了又一种选择。不过考虑到Apple如果继续严格审核的话，可能只有杂志报刊类应用能够取得这个权限吧。另外需要注意开发者仅只能指定一个最小间隔，最后下没下估计就得看系统娘的心情了。</li>
<li>同样是后台下载，以前只能推送提醒用户进入应用下载，现在可以接到推送并在后台下载。UIBackgroundModes设为remote-notification，并实现<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code></li>
</ul>


<p>为后台下载，开发者必须使用一个新的类<code>NSURLSession</code>，其实就是在NSURLConnection上加了个后台处理，使用类似，API十分简单，不再赘述。</p>

<h3>AirDrop</h3>

<p>这个是iOS7的重头新功能，用户可以用它来分享照片，文档，链接，或者其他数据给附近的设备。但是不需要特别的实现，被集成在了标准的UIActivityViewController里，并没有单独的API提供。数据的话，可以通过实现UIActivityItemSource接口后进行发送。大概苹果也不愿意看到超出他们控制的文件分享功能吧，毕竟这和iOS设计的初衷不一样。如果你不使用UIActivityViewController的话，可能是无法在应用里实装AirDrop功能了。</p>

<h3>地图</h3>

<p>Apple在继续在地图应用上的探索，MapKit的改进也乏善可陈。我一直相信地图类应用的瓶颈一定在于数据，但是对于数据源的建立并不是一年两年能够完成的。Google在这一块凭借自己的搜索引擎有着得天独厚的优势，苹果还差的很远很远。看看有哪些新东西吧：</p>

<ul>
<li>MKMapCamera，可以将一个MKMapCamera对象添加到地图上，在指明位置，角度和方向后将呈现3D的样子…大概可以想象成一个数字版的Google街景..</li>
<li>MKDirections 获取Apple提供的基于方向的路径，然后可以用来将路径绘制在自己的应用中。这可能对一些小的地图服务提供商产生冲击，但是还是那句话，地图是一个数据的世界，在拥有完备数据之前，Apple不是Google的对手。这个状况至少会持续好几年（也有可能是永远）。</li>
<li>MKGeodesicPolyline 创建一个随地球曲率的线，并附加到地图上，完成一些视觉效果。</li>
<li>MKMapSnapshotter 使用其拍摄基于地图的照片，也许各类签到类应用会用到</li>
<li>改变了overlay物件的渲染方式</li>
</ul>


<h3>Inter-App Audio 应用间的音频</h3>

<p>AudioUnit框架中加入了在同一台设备不同应用之间发送MIDI指令和传送音频的能力。比如在一个应用中使用AudioUnit录音，然后在另一个应用中打开以处理等。在音源应用中声明一个AURemoteIO实例来标为Inter-App可用，在目标应用中使用新的发现接口来发现并获取音频。
想法很好，也算是在应用内共享迈出了一步，不过我对现在使用AudioUnit这样的低层级框架的应用数量表示不乐观。也许今后会有一些为更高层级设计的共享API提供给开发者使用。毕竟要从AudioUnit开始处理音频对于大多数开发者来说并不是一件很容易的事情。</p>

<h3>点对点连接 Peer-to-Peer Connectivity</h3>

<p>可以看成是AirDrop不能直接使用的补偿，代价是需要自己实现。MultipeerConnectivity框架可以用来发现和连接附近的设备，并传输数据，而这一切并不需要有网络连接。可以看到Apple逐渐在文件共享方面一步步放开限制，但是当然所有这些都还是被限制在sandbox里的。</p>

<h3>Store Kit Framework</h3>

<p>Store Kit在内购方面采用了新的订单系统，这将可以实现对订单的本机验证。这是一次对应内购破解和有可能验证失败导致内购失败的更新，苹果希望藉此减少内购的实现流程，减少出错，同时遏制内购破解泛滥。前者可能没有问题，但是后者的话，因为objc的动态特性，决定了只要有越狱存在，内购破解也是早晚的事情。不过这一点确实方便了没有能力架设验证服务器的小开发者，这方面来说还是很好的。</p>

<h3>最后</h3>

<p>当然还有一些其他小改动，包括MessageUI里添加了附件按钮，Xcode开始支持模块了等等。完整的iOS7新特性列表可以在<a href="https://developer.apple.com/library/prerelease/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS7.html#//apple_ref/doc/uid/TP40013162-SW1">这里</a>找到（暂时应该也需要开发者账号）。最后一个好消息是，苹果放慢了废弃API的速度，这个版本并没有特别重要的API被标为Deprecated，Cheers。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中使用blend改变图片颜色]]></title>
    <link href="http://onevcat.com/2013/04/using-blending-in-ios/"/>
    <updated>2013-04-29T16:30:00+09:00</updated>
    <id>http://onevcat.com/2013/04/using-blending-in-ios</id>
    <content type="html"><![CDATA[<p><img src="http://img.onevcat.com/2013/blend_title.png" alt="使用Blend处理图片颜色" /></p>

<p>最近对<code>Core Animation</code>和<code>Core Graphics</code>的内容东西比较感兴趣，自己之前也在这块相对薄弱，趁此机会也想补习一下这块的内容，所以之后几篇可能都会是对CA和CG学习的记录的文章。</p>

<p>在应用里一个很常见的需求是主题变换：同样的图标，同样的素材，但是需要按照用户喜爱变为不同的颜色。在iOS5和6的SDK里部分标准控件引入了<code>tintColor</code>，来满足个性化界面的需求，但是Apple在这方面还远远做的不够。一是现在用默认控件根本难以做出界面优秀的应用，二是<code>tintColor</code>所覆盖的并不够全面，在很多情况下开发者都无法使用其来完成个性化定义。解决办法是什么？最简单当然是拜托设计师大大出图，想要蓝色主题？那好，开PS盖个蓝色图层出一套蓝色的UI；又想加粉色UI，那好，再出一套粉色的图然后导入Xcode。代码上的话根据颜色需求使用image-blue或者image-pink这样的名字来加载图片。</p>

<p>如果有一丁点重构的意识，就会知道这不是一个很好的解决方案。工程中存在大量的冗余和重复（就算你要狡辩这些图片颜色不同不算重复，你也会在内心里知道这种狡辩是多么无力），这是非常致命的。想象一下如果你有10套主题界面，先不论应用的体积会膨胀到多少，光是想做一点修改就会痛苦万分，比如希望改一下某个按钮的形状，很好，设计师大大请重复地修改10遍，并出10套UI，然后一系列的重命名，文件移动和导入…一场灾难。</p>

<p>当然有其他办法，因为说白了就是tint不同的颜色到图片上而已，如果我们能实现改变UIImage的颜色，那我们就只需要一套UI，然后用代码来改变UI的颜色就可以了，生活有木有一下光明起来呀。嗯，让我们先从一张图片开始吧～下面是一张带有alpha通道的图片，原始颜色是纯的灰色（当然什么颜色都可以，只不过我这个人现在暂时比较喜欢灰色而已）。</p>

<!-- more -->


<p><img src="http://img.onevcat.com/2013/blend_origin.png" alt="要处理的原图" /></p>

<p>我们将用blending给这张图片加上另一个纯色作为tint，并保持原来的alpha通道。用Core Graphics来做的话，大概的想法很直接：</p>

<ol>
<li>创建一个上下文用以画新的图片</li>
<li>将新的tintColor设置为填充颜色</li>
<li>将原图片画在创建的上下文中，并用新的填充色着色（注意保持alpha通道）</li>
<li>从当前上下文中取得图片并返回</li>
</ol>


<p>最麻烦的部分可能就是保持alpha通道了。<a href="https://developer.apple.com/library/ios/#documentation/UIKit/Reference/UIImage_Class/Reference/Reference.html">UIImage的文档</a>中提供了使用blend绘图的方法<code>drawInRect:blendMode:alpha:</code>，<code>rect</code>和<code>alpha</code>都没什么问题，但是<code>blendMode</code>是个啥玩意儿啊…继续看文档，关于<a href="https://developer.apple.com/library/ios/#documentation/GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGBlendMode"><code>CGBlendMode</code>的文档</a>，里面有一大堆看不懂的枚举值，比如这样：</p>

<p><code>
kCGBlendModeDestinationOver
R = S*(1 - Da) + D
Available in iOS 2.0 and later.
Declared in CGContext.h.
</code></p>

<p>完全不懂..直接看之后的Discussion部分：</p>

<blockquote><p>The blend mode constants introduced in OS X v10.5 represent the Porter-Duff blend modes. The symbols in the equations for these blend modes are:<br/>
R is the premultiplied result<br/>
S is the source color, and includes alpha<br/>
D is the destination color, and includes alpha<br/>
Ra, Sa, and Da are the alpha components of R, S, and D</p></blockquote>

<p>原来如此，R表示结果，S表示包含alpha的原色，D表示包含alpha的目标色，Ra，Sa和Da分别是三个的alpha。明白了这些以后，就可以开始寻找我们所需要的blend模式了。相信你可以和我一样，很快找到这个模式：</p>

<p><code>
kCGBlendModeDestinationIn
R = D*Sa
Available in iOS 2.0 and later.
Declared in CGContext.h.
</code></p>

<p>结果 = 目标色和原色透明度的加成，看起来正式所需要的。啦啦啦，还等什么呢，开始动手实现看看对不对吧～</p>

<p>为了以后使用方便，当然是祭出Category，先创建一个UIImage的类别：</p>

<p>```objc
//  UIImage+Tint.h</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>@interface UIImage (Tint)</p>

<ul>
<li>(UIImage <em>) imageWithTintColor:(UIColor </em>)tintColor;</li>
</ul>


<p>@end
```
暂时先这样，当然我们也可以创建一个类方法直接完成从bundle读取图片然后加tintColor，但是很多时候并不如上面一个实例方法方便（比如想要从非bundle的地方获取图片），这个问题之后再说。那么就按照之前设想的步骤来实现吧：</p>

<p>```objc
//  UIImage+Tint.m</p>

<h1>import "UIImage+Tint.h"</h1>

<p>@implementation UIImage (Tint)
- (UIImage <em>) imageWithTintColor:(UIColor </em>)tintColor
{</p>

<pre><code>//We want to keep alpha, set opaque to NO; Use 0.0f for scale to use the scale factor of the device’s main screen.
UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0f);
[tintColor setFill];
CGRect bounds = CGRectMake(0, 0, self.size.width, self.size.height);
UIRectFill(bounds);

//Draw the tinted image in context
[self drawInRect:bounds blendMode:kCGBlendModeDestinationIn alpha:1.0f];

UIImage *tintedImage = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();

return tintedImage;
</code></pre>

<p>}
@end
```</p>

<p>简单明了，没有任何难点。测试之：<code>[[UIImage imageNamed:@"image"] imageWithTintColor:[UIColor orangeColor]];</code>，得到的结果为：</p>

<p><img src="http://img.onevcat.com/2013/blend_1.png" alt="使用kCGBlendModeDestinationIn模式的结果" /></p>

<p>嗯...怎么说呢，虽然tintColor的颜色是变了，但是总觉得怪怪的。仔细对比一下就会发现，原来灰色图里星星和周围的灰度渐变到了橙色的图里好像都消失了：星星整个变成了橙色，周围的一圈漂亮的光晕也没有了，这是神马情况啊…这种图能交差的话那算见鬼了，会被设计和产品打死的吧。对于无渐变的纯色图的图来说直接用上面的方法是没问题的，但是现在除了Metro的大色块以外哪里无灰度渐变的设计啊…检查一下使用的blend，<code>R = D * Sa</code>，恍然大悟，我们虽然保留了原色的透明度，但是却把它的所有的灰度信息弄丢了。怎么办？继续刨<code>CGBlendMode</code>的文档吧，那么多blend模式应该总有我们需要的。功夫不负有心人，<code>kCGBlendModeOverlay</code>一副嗷嗷待选的样子：</p>

<p><code>
kCGBlendModeOverlay
Either multiplies or screens the source image samples with the background image samples, depending on the background color. The result is to overlay the existing image samples while preserving the highlights and shadows of the background. The background color mixes with the source image to reflect the lightness or darkness of the background.
Available in iOS 2.0 and later.
Declared in CGContext.h.
</code></p>

<p>kCGBlendModeOverlay可以保持背景色的明暗，也就是灰度信息，听起来正是我们需要的。加入到声明中，并且添加相应的实现( 顺便重构一下原来的代码 :) )：</p>

<p>```objc
//  UIImage+Tint.h</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>@interface UIImage (Tint)</p>

<ul>
<li>(UIImage <em>) imageWithTintColor:(UIColor </em>)tintColor;</li>
<li>(UIImage <em>) imageWithGradientTintColor:(UIColor </em>)tintColor;</li>
</ul>


<p>@end
```</p>

<p>```objc
//  UIImage+Tint.m</p>

<h1>import "UIImage+Tint.h"</h1>

<p>@implementation UIImage (Tint)
- (UIImage <em>) imageWithTintColor:(UIColor </em>)tintColor
{</p>

<pre><code>return [self imageWithTintColor:tintColor blendMode:kCGBlendModeDestinationIn];
</code></pre>

<p>}</p>

<ul>
<li><p>(UIImage <em>) imageWithGradientTintColor:(UIColor </em>)tintColor
{
  return [self imageWithTintColor:tintColor blendMode:kCGBlendModeOverlay];
}</p></li>
<li><p>(UIImage <em>) imageWithTintColor:(UIColor </em>)tintColor blendMode:(CGBlendMode)blendMode
{
  //We want to keep alpha, set opaque to NO; Use 0.0f for scale to use the scale factor of the device’s main screen.
  UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0f);
  [tintColor setFill];
  CGRect bounds = CGRectMake(0, 0, self.size.width, self.size.height);
  UIRectFill(bounds);</p>

<p>  //Draw the tinted image in context
  [self drawInRect:bounds blendMode:blendMode alpha:1.0f];</p>

<p>  UIImage *tintedImage = UIGraphicsGetImageFromCurrentImageContext();
  UIGraphicsEndImageContext();</p>

<p>  return tintedImage;
}</p></li>
</ul>


<p>@end
```</p>

<p>完成，测试之…好吧，好尴尬，虽然颜色和周围的光这次对了，但是透明度又没了啊魂淡..一点不奇怪啊，因为<code>kCGBlendModeOverlay</code>本来就没承诺给你保留原图的透明度的说。</p>

<p><img src="http://img.onevcat.com/2013/blend_2.png" alt="使用kCGBlendModeOverlay模式的结果" /></p>

<p>那么..既然我们用<code>kCGBlendModeOverlay</code>能保留灰度信息，用<code>kCGBlendModeDestinationIn</code>能保留透明度信息，那就两个blendMode都用不就完事儿了么～尝试之，如果在blend绘图时不是<code>kCGBlendModeDestinationIn</code>模式的话，则再用<code>kCGBlendModeDestinationIn</code>画一次：</p>

<p>```objc
//  UIImage+Tint.m</p>

<h1>import "UIImage+Tint.h"</h1>

<p>@implementation UIImage (Tint)
- (UIImage <em>) imageWithTintColor:(UIColor </em>)tintColor
{</p>

<pre><code>return [self imageWithTintColor:tintColor blendMode:kCGBlendModeDestinationIn];
</code></pre>

<p>}</p>

<ul>
<li><p>(UIImage <em>) imageWithGradientTintColor:(UIColor </em>)tintColor
{
  return [self imageWithTintColor:tintColor blendMode:kCGBlendModeOverlay];
}</p></li>
<li><p>(UIImage <em>) imageWithTintColor:(UIColor </em>)tintColor blendMode:(CGBlendMode)blendMode
{
  //We want to keep alpha, set opaque to NO; Use 0.0f for scale to use the scale factor of the device’s main screen.
  UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0f);
  [tintColor setFill];
  CGRect bounds = CGRectMake(0, 0, self.size.width, self.size.height);
  UIRectFill(bounds);</p>

<p>  //Draw the tinted image in context
  [self drawInRect:bounds blendMode:blendMode alpha:1.0f];</p>

<p>  if (blendMode != kCGBlendModeDestinationIn) {</p>

<pre><code>  [self drawInRect:bounds blendMode:kCGBlendModeDestinationIn alpha:1.0f];
</code></pre>

<p>  }</p>

<p>  UIImage *tintedImage = UIGraphicsGetImageFromCurrentImageContext();
  UIGraphicsEndImageContext();</p>

<p>  return tintedImage;
}</p></li>
</ul>


<p>@end
```</p>

<p>结果如下：</p>

<p><img src="http://img.onevcat.com/2013/blend_3.png" alt="使用kCGBlendModeOverlay和kCGBlendModeDestinationIn模式的结果" /></p>

<p>已经很完美了，这样的话只要在代码里设定一下颜色，我们就能够很轻易地使用同样一套UI，将其blend为需要的颜色，来实现素材的重用了。唯一需要注意的是，因为每次使用<code>UIImage+Tint</code>的方法绘图时，都使用了CG的绘制方法，这就意味着每次调用都会是用到CPU的Offscreen drawing，大量使用的话可能导致性能的问题（主要对于iPhone 3GS或之前的设备，可能同时处理大量这样的绘制调用的能力会有不足）。关于CA和CG的性能的问题，打算在之后用一篇文章来介绍一下。对于这里的<code>UIImage+Tint</code>的实现，可以写一套缓存的机制，来确保大量重复的元素只在load的时候blend一次，之后将其缓存在内存中以快速读取。当然这是一个权衡的问题，在时间和空间中做出正确的平衡和选择，也正是程序设计的乐趣所在。</p>

<p>这篇文章中作为示例的工程和UIImage+Tint可以在<a href="https://github.com/onevcat/VVImageTint">Github</a>上找到，您可以随意玩弄..我相信也会是个来研究每种blend的特性的好机会～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[两个人一起记账吧～ Our Money]]></title>
    <link href="http://onevcat.com/2013/04/our-money-app/"/>
    <updated>2013-04-06T11:54:00+09:00</updated>
    <id>http://onevcat.com/2013/04/our-money-app</id>
    <content type="html"><![CDATA[<p><a href="https://itunes.apple.com/cn/app/our-money/id562520527?ls=1&amp;mt=8"><img src="http://img.onevcat.com/2013/ourmoney-banner.jpg" alt="image" /></a></p>

<p>Our Money是一款能够协助多人在云端记账的iOS应用，可以帮助您简单地记录和整理日常开销，您可以邀请您的朋友和家人与您一起记账，免去每日汇报总结之苦。</p>

<ul>
<li><a href="https://itunes.apple.com/cn/app/our-money/id562520527?ls=1&amp;mt=8">App Store地址</a></li>
<li><a href="http://ourmoney.onevcat.com">Our Money app的首页</a></li>
</ul>


<p>大概但凡从按月领生活费开始花钱以来，都会兴起记账的念头，至于是否能够坚持，就各凭本事了。说到自己，则是多次付诸行动，然后不了了之。从一开始记在小本本上自己用计算器加加减减，到建个Excel文档自动求和，再到手机上的记账应用，时代在进步，咱的手段也在进步，却总还觉得没有找到最合适的工具。尤其是用手机记账以来，有的软件，每次对非得给一笔开销定义出两层的分类，让我头疼不已，家庭小帐非得整成个公司帐簿，改动标签也颇为麻烦；有的软件，记录条目倒是简单，但其他诸如统计等功能却也一起被简化了。不过，最让我郁闷的是，记账总成为我一个人的事情，谁让是用我的手机在记呢。</p>

<p>现在，终于等到了一款操作简单但是功能齐全，尤其是，<strong>可以多人共同记账的应用</strong>。这款叫做Our Money 的应用，最大的亮点当然就在于“Our”。它可以实现多人一起记账，只要人手一个应用，就可以和家人一起记录家庭开销，和朋友一起整理出游费用，不同的帐本可以选择和不同的人分享，每个人都能参与，条目更新实时同步，再不用一个人负责所有的帐目。</p>

<p>好啦，废话不多说，让我们一起来体验一下这个软件吧。<a href="https://itunes.apple.com/cn/app/our-money/id562520527?ls=1&amp;mt=8">下载应用</a>并打开，用邮箱注册用户，就可以开始记账啦。请记住你的邮箱是你邀请别人或者别人邀请你共同记账的标识哦～</p>

<!-- more -->




<br>


<p><img src="http://img.onevcat.com/2013/1-ourmoney-login.png" alt="OurMoney的注册登陆界面" />
Our Money的主界面相当简洁，最上方列出列表名称，收入（预算）、支出、结余也一目了然，条目的时间、分类、备注都一目了然。那么其他其他内容被藏在哪里呢？左边一拉，当前列表的按月总计；右边一拉，列表编辑，数据统计，就是这么简单～</p>

<br>


<p><img src="http://img.onevcat.com/2013/2-ourmoney-month.png" alt="按月份统计收入和开销" /></p>

<br>


<p><img src="http://img.onevcat.com/2013/3-ourmoney-stat.png" alt="按项目和用户的统计" />
首先我们新建一个列表， 在右边的界面下拉一下，就可以新建自己的列表了。选中的列表下方能够修改列表名称或者删除，中间的邀请就是重头戏啦，输入希望一同记账的朋友的邮箱，他就可以收到邀请并加入你的列表。当邀请了朋友或家人加入列表后，列表信息中就会显示多人同为列表用户。当然，在记账时随时可以邀请新的用户加入。</p>

<br>


<p><img src="http://img.onevcat.com/2013/4-ourmoney-invite.png" alt="邀请别人加入特定列表一起记账" />
选定刚才新建的列表，回到主界面，随便记下一点东西，在同一列表中的用户将通过推送（如果允许的话）收到您更改了列表的消息。而对方打开应用时，马上就可以同步地看到您所记录的信息，这便于双方更迅速地各自完成记账，免去了回家后苦苦思索或者汇总的麻烦，确实十分方便。</p>

<br>


<p><img src="http://img.onevcat.com/2013/5-ourmoney-push.png" alt="家人或朋友记账后，立即可以收到系统提醒" /></p>

<p>记错了，找不到修改的地方怎么办？点一下，记录被选中，下面就出现了编辑或者删除的选项，还可以分享条目到社交网络，秀一下收到的礼物什么的哦～</p>

<p>在消费和记账时难免会出现没有网络的尴尬时候，这时候Our Money还能正常工作么？当然，Our Money具有完善的离线模式处理，没有网络时照常使用，当之后连上网络的时候会自动为您完成所有同步，完全不用自己操心。</p>

<br>


<p><img src="http://img.onevcat.com/2013/6-ourmoney-offline.png" alt="Our Money方便的离线模式" /></p>

<p>总的来说Our Money是一款功能强大但又简单高效的记账软件，其云端记账和共同记账的理念很符合当今多人记账的需求。从今天开始就和家人朋友用Our Money一起记账吧～</p>

<p>您可以从<a href="https://itunes.apple.com/cn/app/our-money/id562520527?ls=1&amp;mt=8">App Store中下载Our Money</a>，还可以进一步通过应用内的赠送系统将您的记账和心得分享给家人朋友。</p>
]]></content>
  </entry>
  
</feed>
